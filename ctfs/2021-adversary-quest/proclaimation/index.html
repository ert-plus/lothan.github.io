<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta itemprop=name content="Proclaimation">
<meta itemprop=description content="Challenge Description:  A mysterious file appeared on a deep dark web forum. Can you figure out what we can&rsquo;t see right now?
 Write-Up: We are given a strange 512 byte file proclaimation.dat that file sees as a boot partition.
$ wc proclamation.dat 1 8 512 proclamation.dat $ xxd proclamation.dat | head 00000000: bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd .. ..0.1....a.a. 00000010: 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2 ."><meta itemprop=datePublished content="2021-02-10T19:47:09-06:00">
<meta itemprop=dateModified content="2021-02-10T19:47:09-06:00">
<meta itemprop=wordCount content="1168">
<meta itemprop=keywords content="AdversaryQuest,CTFs,"><meta property="og:title" content="Proclaimation">
<meta property="og:description" content="Challenge Description:  A mysterious file appeared on a deep dark web forum. Can you figure out what we can&rsquo;t see right now?
 Write-Up: We are given a strange 512 byte file proclaimation.dat that file sees as a boot partition.
$ wc proclamation.dat 1 8 512 proclamation.dat $ xxd proclamation.dat | head 00000000: bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd .. ..0.1....a.a. 00000010: 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2 .">
<meta property="og:type" content="article">
<meta property="og:url" content="https://joe.lothan.net/ctfs/2021-adversary-quest/proclaimation/"><meta property="article:section" content="ctfs">
<meta property="article:published_time" content="2021-02-10T19:47:09-06:00">
<meta property="article:modified_time" content="2021-02-10T19:47:09-06:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Proclaimation">
<meta name=twitter:description content="Challenge Description:  A mysterious file appeared on a deep dark web forum. Can you figure out what we can&rsquo;t see right now?
 Write-Up: We are given a strange 512 byte file proclaimation.dat that file sees as a boot partition.
$ wc proclamation.dat 1 8 512 proclamation.dat $ xxd proclamation.dat | head 00000000: bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd .. ..0.1....a.a. 00000010: 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2 .">
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/safari-pinned-tab.svg color>
<link rel="shortcut icon" href=/favicon.ico>
<title>Proclaimation</title>
<link rel=stylesheet href=https://joe.lothan.net/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin=anonymous>
</head>
<body id=page>
<header id=site-header class="animated slideInUp">
<div class="hdr-wrapper section-inner">
<div class=hdr-left>
<div class=site-branding>
<a href=https://joe.lothan.net/>Joe Lothan</a>
</div>
<nav class="site-nav hide-in-mobile">
<a href=https://joe.lothan.net/ctfs/>CTFs</a>
</nav>
</div>
<div class="hdr-right hdr-icons">
<span class="hdr-social hide-in-mobile"><a href=https://github.com/lothan target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button>
</div>
</div>
</header>
<div id=mobile-menu class="animated fast">
<ul>
<li><a href=https://joe.lothan.net/ctfs/>CTFs</a></li>
</ul>
</div>
<main class="site-main section-inner thin animated fadeIn faster">
<h1>Proclaimation</h1>
<div class=content>
<h4 id=challenge-description>Challenge Description:<a href=#challenge-description class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4>
<blockquote>
<p>A mysterious file appeared on a deep dark web forum. Can you figure out what we can&rsquo;t see right now?</p>
</blockquote>
<h4 id=write-up>Write-Up:<a href=#write-up class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4>
<p>We are given a strange 512 byte file <code>proclaimation.dat</code> that <code>file</code> sees as a boot partition.</p>
<pre tabindex=0><code>$ wc proclamation.dat
  1   8 512 proclamation.dat
$ xxd proclamation.dat | head
00000000: bc00 20b4 0730 c031 c9b7 8ab6 61b2 61cd  .. ..0.1....a.a.
00000010: 10b4 0231 d230 ffcd 10eb 465e 83c6 14b2  ...1.0....F^....
00000020: 0966 52b3 00b4 0e8a 0483 c601 665a 66c1  .fR.........fZf.
00000030: e202 6683 c242 6681 e2ff 0000 0066 31d0  ..f..Bf......f1.
00000040: 6652 0c00 7419 88c2 80f2 0a74 04cd 10eb  fR..t......t....
00000050: d2b4 03cd 10b4 02fe c6b2 00cd 10eb c4fa  ................
00000060: f4e8 b7ff 796f 7527 7265 206f 6e20 6120  ....you're on a 
00000070: 676f 6f64 2077 6179 2ebf c686 85c4 cabd  good way........
00000080: 8fca 8b98 8fca 8685 8581 8384 8dca 8c85  ................
00000090: 98ca 8283 8d82 8693 ca83 849e 8f86 8683  ................
$ file proclamation.dat 
proclamation.dat: DOS/MBR boot sector
</code></pre><p>I did not trust <code>file</code> for way too long, because initially I did not know what to do with a boot partition. After looking at the file every which way, I finally tried to treat the file as a disk image and boot to it</p>
<pre tabindex=0><code>$ qemu-system-i386 -drive format=raw,file=proclamation.dat
</code></pre><p><img src=images/booting-proclamation.png alt="booting the proclamation file"></p>
<p>Aha! Now we know what the file is, we need to examine the bootloader and how it works in order to get our flag. Thankfully qemu has a built in gdb debugger that allows you to step through the execution of the bootloader and examine memory to see how it works. <a href=https://weinholt.se/articles/debugging-boot-sectors/>These instructions</a> were helpful in getting set up.</p>
<pre tabindex=0><code>$ qemu-system-i386 -s -fda proclamation.dat -boot a
</code></pre><p><img src=images/proclamation-gdb-start.png alt="using gdb to debug the bootloader"></p>
<p>The bootloader uses <code>8086</code> architecture, the precursor to intel&rsquo;s <code>x86</code> architecture. It is only 16-bit but uses two registers, a <strong>segment</strong> and an <strong>offset</strong> to have access to a 20-bit address space. So in order to find the address of the current 8086 instruction, we multiply the segment containing code <code>$cs</code> by 16 and add the offset, <code>$pc</code> the program counter (aka <code>%eip</code>).</p>
<p>This turns out to be a huge pain to deal with in regular gdb. Trying to examine the stack becomes very difficult and gdb&rsquo;s examine instruction <code>x/i</code> sometimes doesn&rsquo;t return the correct <code>8086</code> instruction. Thankfully, <a href=https://ternet.fr/gdb_real_mode.html>someone wrote an amazing gdb script</a> to help debug <code>8086</code> code.</p>
<p>Using this mode, let&rsquo;s debug the bootloader to find out how it prints its message even though the message isn&rsquo;t in <code>proclamation.dat</code>&rsquo;s plaintext. The bootloader code is loaded at <code>0x7c00</code> so if we disassemble the instructions, we can see a bit of what it does.</p>
<p><img src=images/proclamation-code.png alt="the bulk of the booloader code"></p>
<p>It&rsquo;s hard to see exactly what&rsquo;s going on, but note the many <code>int 0x10</code> instructions, a <a href=https://en.wikipedia.org/wiki/INT_10H>bios system call</a> to handle video output. Setting <code>b</code>reakpoints at all of them and <code>c</code>ontinuing until the text starts to output, we find that <code>0x7c4d</code> is the call that actually outputs a character of the proclamation to screen. After outputting the character, it <code>jmp</code>s back to <code>0x7c23</code>.</p>
<p>So let&rsquo;s take a closer look at this loop between <code>0x7c23</code> until <code>0x7c4f</code>. The gdb &ldquo;real mode&rdquo; script helps immensely with understanding what the registers and stack looks like in <code>8086</code>. Before printing the ascii character <code>W</code> to the screen, here is what the bootloader looks like at the start of the loop at <code>0x7x23</code>:</p>
<p><img src=images/proclamation-before-loop.png alt="gdb &ldquo;real mode&rdquo; at the start of the loop"></p>
<p>And here is what is looks like at the end of the loop, before running the system call to update the screen. Note that <code>AX</code> is set to <code>0x0E57</code> which tells the <a href=https://en.wikipedia.org/wiki/INT_10H>video system call</a> to teletype output (<code>0x0E</code>) the ASCII character <code>W</code> (<code>0x57</code>)
<img src=images/proclamation-end-loop.png alt="gdb &ldquo;real mode&rdquo; at the end of the loop"></p>
<p>Let&rsquo;s take a closer look at the code in this loop. Some of the gdb disassembly doesn&rsquo;t get all of the 8086 instructions right, so to be sure, we should dump instruction memory and use a dedicated disassembler like <code>ndisasm</code>.</p>
<pre tabindex=0><code>(gdb) dump binary memory loop-code.bin 0x7c23 0x7c51
(gdb) quit
$ ndisasm -o $((0x7c23)) loop-code.bin | head -5
00007C23  B300              mov bl,0x0
00007C25  B40E              mov ah,0xe
00007C27  8A04              mov al,[si]
00007C29  83C601            add si,byte +0x1
00007C2C  665A              pop edx
</code></pre><p>Here is how I understand the loop code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-NASM data-lang=NASM><span style=color:#a6e22e>mov</span> bl,<span style=color:#ae81ff>0x0</span>		   <span style=color:#75715e>; set the offset (BX) to 0</span>
<span style=color:#a6e22e>mov</span> ah,<span style=color:#ae81ff>0xe</span>     	   <span style=color:#75715e>; set the higher byte of AX to e</span>
    	    	   <span style=color:#75715e>; used to tell our system call to teletype output</span>
<span style=color:#a6e22e>mov</span> al,[si]  	   <span style=color:#75715e>; get the next character from the &#34;source index&#34;</span>
    		   	   <span style=color:#75715e>; often used to store strings and then </span>
<span style=color:#a6e22e>add</span> si,<span style=color:#66d9ef>byte</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x1</span>   <span style=color:#75715e>; increment the string pointer</span>
<span style=color:#a6e22e>pop</span> edx	     	   <span style=color:#75715e>; grab the top of the stack and store it in DX</span>
<span style=color:#a6e22e>shl</span> edx,<span style=color:#66d9ef>byte</span> <span style=color:#ae81ff>0x2</span>   <span style=color:#75715e>; do some weird bitwise math with DX</span>
<span style=color:#a6e22e>add</span> edx,<span style=color:#66d9ef>byte</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>0x42</span> <span style=color:#75715e>; this math starts off changing every char output, </span>
<span style=color:#a6e22e>and</span> edx,<span style=color:#ae81ff>0xff</span> 	   <span style=color:#75715e>; but stablizes to have 0xEA input and 0xEA output </span>
<span style=color:#a6e22e>xor</span> eax,edx	   	   <span style=color:#75715e>; xor the char from the input string with 0xEA</span>
<span style=color:#a6e22e>push</span> edx		   <span style=color:#75715e>; save 0xEA back on the stack</span>
<span style=color:#a6e22e>or</span> al,<span style=color:#ae81ff>0x0</span>		   <span style=color:#75715e>; check if the character is the null byte</span>
<span style=color:#a6e22e>jz</span> <span style=color:#ae81ff>0x7c5f</span>		   <span style=color:#75715e>; if so, jump to the end</span>
<span style=color:#a6e22e>mov</span> dl,al		   <span style=color:#75715e>; check if the character</span>
<span style=color:#a6e22e>xor</span> dl,<span style=color:#ae81ff>0xa</span>		   <span style=color:#75715e>; is 0x0a, the newline character</span>
<span style=color:#a6e22e>jz</span> <span style=color:#ae81ff>0x7c51</span>		   <span style=color:#75715e>; if so jump to code to go to the next line</span>
<span style=color:#a6e22e>int</span> <span style=color:#ae81ff>0x10</span>		   <span style=color:#75715e>; execute our system call to print the xored char</span>
<span style=color:#a6e22e>jmp</span> short <span style=color:#ae81ff>0x7c23</span>	   <span style=color:#75715e>; start over</span>
</code></pre></div><p>We could XOR the initial file with <code>0xEA</code> to find our flag but for extra swag points lets change the null byte that ends the proclamation with a space so the bootloader keeps printing. The null byte will be <code>0xEA</code> in the original proclamation and a space character <code>0x20</code> XORed with <code>0xEA</code> makes <code>0xCA</code>. So:</p>
<pre tabindex=0><code>$ xxd proclamation.dat &gt; proclamation.hex
$ grep ea proclamation.hex 
000001c0: 828b 84ca 9e8b 8899 cbea 8119 11a9 b991  ................
000001e0: da9e 86da 8b8e d998 9797 eaf4 f4f4 f4f4  ................
$ sed 's/cbea/cbca/g' proclamation.hex | xxd -r &gt; new-proclamation.dat
$ qemu-system-i386 -drive format=raw,file=new-proclamation.dat
</code></pre><p><img src=images/proclamation-flag.png alt="proclamation&rsquo;s flag"></p>
<p>What would have made this challenge even harder is to make the bitwise math more interesting. The progression of <code>DX</code> is <code>0x09</code>-> <code>0x66</code> -> <code>0xDA</code> -> <code>0xAA</code> -> <code>0xEA</code> -> <code>0xEA</code> -> <code>0xEA</code> etc is somewhat uninteresting, practically we only need to XOR the file with <code>0xEA</code>. I checked the algorithm in the challenge (shift left 2 and add 42) and all intial values (<code>0x00</code> to <code>0xFF</code>) produce <code>0xEA</code> after a few iterations, so it seems to be a problem with the algorithm. You could say the sequence &ldquo;degenerates&rdquo; into just a single byte rather than making an interesting cycle.</p>
<p>Though it does raise an interesting math question: which bitwise algorithms, when repeatedly done on just one byte, &ldquo;degenerate&rdquo; and which ones produce more interesting results? Which operations (+, -, *, /, &#171;, &#187;, ^, &) help and hurt? What length cycles can you produce? The few simple add and left shift algorithms I tried all seem to &ldquo;degenerate&rdquo;. But using right shifts I found some cycles of 2 and 4.</p>
<p>P.S: From <a href=https://www.crowdstrike.com/blog/adversary-quest-walkthrough-four-space-jackal-hacktivist-challenges/>Crowdstrike&rsquo;s writeup of this challenge</a>, they recognize the &ldquo;degrated&rdquo; nature of this &ldquo;algorithm&rdquo;. They also name this type of algorithm: its a <a href=https://en.wikipedia.org/wiki/Linear_congruential_generator>Linear Congruential Generator</a>.</p>
</div>
</main>
<footer id=site-footer class="section-inner thin animated fadeIn faster">
<p>&copy; 2021 <a href=https://joe.lothan.net/>Joe Lothan</a></p>
<p>
Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://joe.lothan.net/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a>
</p>
</footer>
<script src=https://joe.lothan.net/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin=anonymous></script>
</body>
</html>